# Data Model: Frontend Web Application

**Feature**: 002-frontend-web-app
**Date**: 2025-12-18
**Phase**: 1 (Design)

## Overview

This document defines the TypeScript data models and entity structures for the frontend application. These types are derived from the backend API contracts and must stay synchronized with the FastAPI SQLModel schemas.

---

## Core Entities

### 1. User

**Description**: Represents an authenticated user of the application. Users are identified by `user_id` extracted from JWT claims.

**TypeScript Type**:
```typescript
// types/user.ts
export interface User {
  id: string;                  // UUID from JWT sub claim
  email: string;               // User's email address
  createdAt: string;           // ISO 8601 timestamp (e.g., "2025-12-18T10:30:00Z")
}
```

**Validation Rules**:
- `id`: Required, non-empty string (UUID format)
- `email`: Required, valid email format
- `createdAt`: Required, ISO 8601 timestamp

**State Management**:
- Stored in `AuthContext` via Better Auth `useSession()` hook
- Persisted in httpOnly cookie by Better Auth
- Accessed via `useAuth()` custom hook

**Lifecycle**:
- Created: On successful sign-up via `/api/auth/signup`
- Updated: Not mutable in MVP (future: profile updates)
- Deleted: Not supported in MVP (future: account deletion)

---

### 2. Task

**Description**: Represents a to-do item owned by a specific user. Tasks are the primary data entity in the application.

**TypeScript Type**:
```typescript
// types/task.ts
export interface Task {
  id: string;                  // UUID generated by backend
  user_id: string;             // Foreign key to User (enforces data isolation)
  title: string;               // Short description (max 200 chars)
  description: string | null;  // Optional detailed info (max 2000 chars)
  completed: boolean;          // Task completion status
  created_at: string;          // ISO 8601 timestamp
  updated_at: string;          // ISO 8601 timestamp
}
```

**Validation Rules** (Client-Side):
```typescript
// lib/validation.ts
import { z } from 'zod';

export const createTaskSchema = z.object({
  title: z.string()
    .min(1, "Title is required")
    .max(200, "Title must be less than 200 characters"),
  description: z.string()
    .max(2000, "Description must be less than 2000 characters")
    .optional()
    .nullable(),
});

export const updateTaskSchema = z.object({
  title: z.string()
    .min(1, "Title is required")
    .max(200, "Title must be less than 200 characters")
    .optional(),
  description: z.string()
    .max(2000, "Description must be less than 2000 characters")
    .optional()
    .nullable(),
  completed: z.boolean().optional(),
});
```

**State Management**:
- Stored in `TaskContext` via `useReducer` hook
- Optimistic updates tracked via state snapshots for rollback
- Synchronized with backend via `/api/{user_id}/tasks` endpoints

**Lifecycle**:
- Created: User submits `TaskForm` → POST `/api/{user_id}/tasks`
- Read: Initial load from Server Component → GET `/api/{user_id}/tasks`
- Updated: Toggle completion, edit details → PATCH `/api/{user_id}/tasks/{id}`
- Deleted: User confirms deletion → DELETE `/api/{user_id}/tasks/{id}`

**Relationships**:
- Belongs to one User (many-to-one)
- User can have many Tasks (one-to-many)
- Foreign key: `user_id` references `User.id`

---

## API Response Types

### ApiResponse<T>

**Description**: Standardized wrapper for all API responses (Constitution Section VII)

**TypeScript Type**:
```typescript
// types/api.ts
export interface ApiResponse<T> {
  data: T;                     // Response payload (typed generically)
  meta?: {                     // Optional metadata
    timestamp?: string;        // Server timestamp
    message?: string;          // Human-readable message
    pagination?: {             // Future: pagination info
      total: number;
      page: number;
      per_page: number;
    };
  };
}
```

**Usage Examples**:
```typescript
// Single task response
ApiResponse<Task>
// { data: { id: "123", title: "...", ... }, meta: { timestamp: "..." } }

// Task list response
ApiResponse<Task[]>
// { data: [{ id: "123", ... }, { id: "456", ... }], meta: { ... } }

// Empty response (e.g., DELETE)
ApiResponse<null>
// { data: null, meta: { message: "Task deleted successfully" } }
```

---

### ApiError

**Description**: Standardized error structure for API failures

**TypeScript Type**:
```typescript
// types/api.ts
export interface ApiError {
  status: number;              // HTTP status code
  message: string;             // User-friendly error message
  details?: {                  // Optional validation errors
    field: string;
    message: string;
  }[];
}
```

**Error Mapping**:
| Status Code | User Message | Action |
|-------------|--------------|--------|
| 401 | (Silent) | Redirect to `/signin` |
| 403 | "Access denied. You don't have permission." | Show toast |
| 404 | "Task not found. It may have been deleted." | Show toast |
| 422 | Validation error details | Inline form errors |
| 500 | "Server error. Please try again." | Show toast |
| Network | "Unable to connect. Check your internet connection." | Show toast |

---

## Form Input Types

### CreateTaskInput

**Description**: User input for creating a new task (before submission)

**TypeScript Type**:
```typescript
// types/task.ts
export interface CreateTaskInput {
  title: string;
  description?: string;
}
```

**Transformation**:
```typescript
// TaskForm.tsx
const onSubmit = async (input: CreateTaskInput) => {
  const validated = createTaskSchema.parse(input); // Zod validation
  const response = await apiClient.post<Task>('/tasks', validated);
  // response.data is now a complete Task with id, timestamps, etc.
};
```

---

### UpdateTaskInput

**Description**: Partial updates to existing task (PATCH semantics)

**TypeScript Type**:
```typescript
// types/task.ts
export interface UpdateTaskInput {
  title?: string;
  description?: string | null;
  completed?: boolean;
}
```

**Usage**:
```typescript
// Toggle completion only
const toggleComplete = async (taskId: string, currentStatus: boolean) => {
  const update: UpdateTaskInput = { completed: !currentStatus };
  await apiClient.patch<Task>(`/tasks/${taskId}`, update);
};

// Edit title and description
const editTask = async (taskId: string, input: { title: string; description: string }) => {
  const update: UpdateTaskInput = { title: input.title, description: input.description };
  await apiClient.patch<Task>(`/tasks/${taskId}`, update);
};
```

---

## Context State Types

### TaskState

**Description**: Global task list state managed by `TaskContext`

**TypeScript Type**:
```typescript
// contexts/TaskContext.tsx
export interface TaskState {
  tasks: Task[];               // Current task list
  loading: boolean;            // Loading indicator for initial fetch
  error: string | null;        // Error message for display
  optimisticSnapshot?: {       // Snapshot for rollback on failure
    tasks: Task[];
    timestamp: number;
  };
}
```

---

### TaskAction

**Description**: Actions for task state reducer (optimistic update pattern)

**TypeScript Type**:
```typescript
// contexts/TaskContext.tsx
export type TaskAction =
  | { type: 'FETCH_REQUEST' }
  | { type: 'FETCH_SUCCESS'; payload: Task[] }
  | { type: 'FETCH_ERROR'; payload: string }
  | { type: 'ADD_TASK_OPTIMISTIC'; payload: Task }
  | { type: 'ADD_TASK_CONFIRMED'; payload: Task } // Update temp ID with real ID
  | { type: 'UPDATE_TASK_OPTIMISTIC'; payload: { id: string; updates: Partial<Task> } }
  | { type: 'DELETE_TASK_OPTIMISTIC'; payload: string }
  | { type: 'REVERT_OPTIMISTIC'; payload: TaskState['optimisticSnapshot'] };
```

**Reducer Logic**:
```typescript
function taskReducer(state: TaskState, action: TaskAction): TaskState {
  switch (action.type) {
    case 'ADD_TASK_OPTIMISTIC':
      return {
        ...state,
        tasks: [action.payload, ...state.tasks], // Prepend to show at top
        optimisticSnapshot: { tasks: state.tasks, timestamp: Date.now() },
      };
    case 'REVERT_OPTIMISTIC':
      return {
        ...state,
        tasks: action.payload?.tasks ?? state.tasks,
        optimisticSnapshot: undefined,
      };
    // ... other cases
  }
}
```

---

## Auth Session Types

### Session

**Description**: Better Auth session object (provided by library)

**TypeScript Type** (from Better Auth):
```typescript
// Better Auth provides this type
export interface Session {
  user: {
    id: string;
    email: string;
    // ... other Better Auth fields
  };
  token: string;               // JWT token
  expiresAt: string;           // Expiration timestamp
}
```

**Access Pattern**:
```typescript
// hooks/useAuth.ts
import { useSession } from 'better-auth/react';

export function useAuth() {
  const { data: session, status } = useSession();

  return {
    user: session?.user ?? null,
    isAuthenticated: status === 'authenticated',
    isLoading: status === 'loading',
  };
}
```

---

## Type Guards & Utilities

### Type Guard Functions

```typescript
// types/task.ts
export function isTask(value: unknown): value is Task {
  return (
    typeof value === 'object' &&
    value !== null &&
    'id' in value &&
    'user_id' in value &&
    'title' in value &&
    'completed' in value
  );
}

export function isTaskArray(value: unknown): value is Task[] {
  return Array.isArray(value) && value.every(isTask);
}
```

---

## Frontend-Backend Type Synchronization

**Process**: Frontend types MUST match backend SQLModel schemas

**Backend Schema** (reference):
```python
# backend/src/models/task.py
from sqlmodel import SQLModel, Field
from datetime import datetime
from uuid import UUID, uuid4

class Task(SQLModel, table=True):
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(foreign_key="user.id")
    title: str = Field(max_length=200)
    description: str | None = Field(default=None, max_length=2000)
    completed: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

**Synchronization Strategy**:
1. Backend generates OpenAPI schema (FastAPI auto-generates)
2. Frontend types manually maintained to match OpenAPI spec
3. Integration tests verify type compatibility (E2E tests)
4. Future: Use `openapi-typescript` to auto-generate types from backend spec

---

## Validation Summary

| Field | Client Validation | Backend Validation | Notes |
|-------|-------------------|-------------------|-------|
| Task.title | Zod: min 1, max 200 | Pydantic: min 1, max 200 | Defense in depth |
| Task.description | Zod: max 2000 | Pydantic: max 2000 | Optional field |
| Task.completed | Type check (boolean) | Pydantic: bool | Toggle only |
| User.email | Better Auth | Pydantic: email format | Auth library handles |

---

## Next Steps

This data model phase is complete. Proceed to:
1. Generate API contracts in `/contracts/` directory
2. Create `quickstart.md` for developer onboarding
3. Update agent context with new type definitions
