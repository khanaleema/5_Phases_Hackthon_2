# Data Model: Backend Core - Auth-Protected Task Management

**Feature**: 001-backend-auth-tasks
**Date**: 2025-12-18
**Status**: Design Complete

## Overview

This document defines the database schema for the task management system using SQLModel. The schema enforces user isolation at the database level through foreign keys and indexes.

---

## Entity Relationship Diagram

```
┌─────────────────────┐
│       User          │
│ (Implicit - Better  │
│  Auth manages this) │
└──────────┬──────────┘
           │
           │ 1:N
           │
           ▼
┌─────────────────────┐
│       Task          │
│───────────────────  │
│ id (PK)            │
│ user_id (FK, IDX)  │◄─── User isolation point
│ title              │
│ description        │
│ completed (IDX)    │
│ created_at         │
│ updated_at         │
└─────────────────────┘
```

---

## Entities

### 1. User (Implicit)

**Ownership**: Managed by Better Auth (frontend)

**Backend Representation**: Only exists as `user_id` strings in JWT tokens and foreign key references.

**Rationale**: Backend is stateless and doesn't manage user authentication. Better Auth handles signup, signin, password resets, etc. Backend only verifies JWT tokens and extracts `user_id`.

**Fields** (for reference only - not stored in backend database):
- `id` (string, UUID) - User's unique identifier from Better Auth
- `email` (string) - User's email address
- `name` (string) - User's display name

---

### 2. Task

**Purpose**: Represents a user's work item with title, description, completion status, and timestamps.

**Table Name**: `tasks`

**SQLModel Definition**:

```python
from sqlmodel import SQLModel, Field
from datetime import datetime
from typing import Optional

class Task(SQLModel, table=True):
    """
    Task model representing a user's work item.

    Attributes:
        id: Auto-increment primary key
        user_id: Foreign key to user (from Better Auth JWT)
        title: Task title (1-200 characters, required)
        description: Optional task description (max 1000 characters)
        completed: Task completion status (default: False)
        created_at: Timestamp when task was created
        updated_at: Timestamp when task was last modified
    """
    __tablename__ = "tasks"

    # Primary Key
    id: Optional[int] = Field(
        default=None,
        primary_key=True,
        description="Auto-increment primary key"
    )

    # Foreign Key (User Isolation)
    user_id: str = Field(
        index=True,
        max_length=255,
        description="User ID from Better Auth JWT token"
    )

    # Task Content
    title: str = Field(
        max_length=200,
        min_length=1,
        description="Task title (required)"
    )

    description: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Optional task description"
    )

    # Task Status
    completed: bool = Field(
        default=False,
        index=True,
        description="Task completion status"
    )

    # Timestamps
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when task was created"
    )

    updated_at: datetime = Field(
        default_factory=datetime.utcnow,
        sa_column_kwargs={"onupdate": datetime.utcnow},
        description="Timestamp when task was last updated"
    )
```

---

## Field Specifications

### Task.id
- **Type**: `int` (auto-increment)
- **Constraints**: Primary key, NOT NULL
- **Default**: Auto-generated by database
- **Purpose**: Unique identifier for tasks
- **Validation**: None (database-managed)

### Task.user_id
- **Type**: `str` (VARCHAR 255)
- **Constraints**: NOT NULL, INDEXED, Foreign key (conceptual - not enforced at DB level since users aren't stored)
- **Purpose**: User isolation - every task belongs to exactly one user
- **Validation**: Must match JWT token `user_id` claim
- **Index**: Required for query performance (all queries filter by user_id)

### Task.title
- **Type**: `str` (VARCHAR 200)
- **Constraints**: NOT NULL, 1-200 characters
- **Purpose**: Brief description of the task
- **Validation**:
  - Minimum length: 1 character
  - Maximum length: 200 characters
  - Cannot be empty string or whitespace only
- **Examples**:
  - Valid: "Buy groceries", "Review pull request #123", "Call dentist"
  - Invalid: "", "   ", (201+ characters)

### Task.description
- **Type**: `str` (VARCHAR 1000, nullable)
- **Constraints**: NULLABLE, max 1000 characters
- **Purpose**: Detailed task information (optional)
- **Validation**:
  - Can be NULL or empty string
  - Maximum length: 1000 characters
- **Examples**:
  - Valid: NULL, "", "Need to buy milk, eggs, and bread from grocery store"
  - Invalid: (1001+ characters)

### Task.completed
- **Type**: `bool`
- **Constraints**: NOT NULL, INDEXED
- **Default**: `False`
- **Purpose**: Track task completion status
- **Validation**: Must be boolean (True/False)
- **Index**: Required for filtering (show pending vs completed tasks)

### Task.created_at
- **Type**: `datetime` (TIMESTAMP)
- **Constraints**: NOT NULL
- **Default**: `datetime.utcnow()` at insert time
- **Purpose**: Track when task was created
- **Validation**: Auto-set by database, cannot be modified

### Task.updated_at
- **Type**: `datetime` (TIMESTAMP)
- **Constraints**: NOT NULL
- **Default**: `datetime.utcnow()` at insert time, auto-updates on modification
- **Purpose**: Track when task was last modified
- **Validation**: Auto-set by database on every update

---

## Indexes

### Primary Index
- **Name**: `tasks_pkey`
- **Columns**: `id`
- **Type**: UNIQUE, PRIMARY KEY
- **Purpose**: Unique task identifier, fast lookups by ID

### User Isolation Index
- **Name**: `ix_tasks_user_id`
- **Columns**: `user_id`
- **Type**: BTREE
- **Purpose**: Fast filtering by user (critical for user isolation)
- **Query Pattern**: `WHERE user_id = ?` (every query uses this)

### Status Filter Index
- **Name**: `ix_tasks_completed`
- **Columns**: `completed`
- **Type**: BTREE
- **Purpose**: Fast filtering by completion status
- **Query Pattern**: `WHERE completed = ?` (show pending vs completed)

### Composite Index (Future Optimization)
- **Name**: `ix_tasks_user_id_completed`
- **Columns**: `user_id, completed`
- **Type**: BTREE
- **Purpose**: Optimize common query pattern (user's pending/completed tasks)
- **Query Pattern**: `WHERE user_id = ? AND completed = ?`
- **Status**: Not required for MVP, add if query performance degrades

---

## Relationships

### Task -> User (Implicit)
- **Type**: Many-to-One
- **Cardinality**: Each task belongs to exactly one user
- **Enforcement**: Application-level (not database-level)
- **Rationale**: Backend doesn't store user records, only user_id strings
- **Query Pattern**: Always filter tasks by user_id from JWT token

---

## Validation Rules

### Title Validation
```python
from pydantic import validator

@validator('title')
def validate_title(cls, v):
    if not v or not v.strip():
        raise ValueError("Title cannot be empty or whitespace only")
    if len(v) > 200:
        raise ValueError("Title cannot exceed 200 characters")
    return v.strip()  # Remove leading/trailing whitespace
```

### Description Validation
```python
@validator('description')
def validate_description(cls, v):
    if v and len(v) > 1000:
        raise ValueError("Description cannot exceed 1000 characters")
    return v
```

### User ID Validation
```python
@validator('user_id')
def validate_user_id(cls, v):
    if not v or not v.strip():
        raise ValueError("User ID cannot be empty")
    return v
```

---

## State Transitions

### Task Lifecycle

```
┌─────────┐
│ Created │
└────┬────┘
     │
     │ (default: completed = False)
     │
     ▼
┌─────────┐       PATCH completed: True       ┌───────────┐
│ Pending ├──────────────────────────────────►│ Completed │
└────┬────┘                                    └─────┬─────┘
     │                                               │
     │                                               │
     │       PATCH completed: False                  │
     └◄──────────────────────────────────────────────┘
     │
     │
     │ DELETE
     ▼
┌─────────┐
│ Deleted │
└─────────┘
```

**State Rules**:
- Tasks are created in `Pending` state (completed = False)
- Tasks can transition between `Pending` and `Completed` states any number of times
- Tasks can be deleted from any state (hard delete, not soft delete)
- `created_at` never changes after creation
- `updated_at` changes on every state transition or content modification

---

## Database Constraints

### NOT NULL Constraints
- `id` - Primary key, always required
- `user_id` - User isolation, always required
- `title` - Task content, always required
- `completed` - Status flag, always required (defaults to False)
- `created_at` - Timestamp, always required
- `updated_at` - Timestamp, always required

### CHECK Constraints (Future)
```sql
-- Title length constraint
ALTER TABLE tasks ADD CONSTRAINT check_title_length CHECK (LENGTH(title) >= 1 AND LENGTH(title) <= 200);

-- Description length constraint
ALTER TABLE tasks ADD CONSTRAINT check_description_length CHECK (description IS NULL OR LENGTH(description) <= 1000);
```
**Status**: Not implemented in MVP (Pydantic validation sufficient)

### UNIQUE Constraints
- None - Multiple users can have tasks with same title

---

## Migration Strategy

### Initial Migration (001)
```python
# alembic/versions/001_create_tasks_table.py
def upgrade():
    op.create_table(
        'tasks',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('user_id', sa.String(length=255), nullable=False),
        sa.Column('title', sa.String(length=200), nullable=False),
        sa.Column('description', sa.String(length=1000), nullable=True),
        sa.Column('completed', sa.Boolean(), nullable=False, server_default='false'),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('now()')),
        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.text('now()')),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index('ix_tasks_user_id', 'tasks', ['user_id'])
    op.create_index('ix_tasks_completed', 'tasks', ['completed'])

def downgrade():
    op.drop_index('ix_tasks_completed', 'tasks')
    op.drop_index('ix_tasks_user_id', 'tasks')
    op.drop_table('tasks')
```

---

## Request/Response Schemas (Pydantic)

### TaskCreate (Request)
```python
from pydantic import BaseModel
from typing import Optional

class TaskCreate(BaseModel):
    title: str
    description: Optional[str] = None
```

### TaskUpdate (Request)
```python
class TaskUpdate(BaseModel):
    title: str
    description: Optional[str] = None
```

### TaskPatch (Request)
```python
class TaskPatch(BaseModel):
    completed: bool
```

### TaskResponse (Response)
```python
from datetime import datetime

class TaskResponse(BaseModel):
    id: int
    user_id: str
    title: str
    description: Optional[str]
    completed: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True  # Allow SQLModel -> Pydantic conversion
```

---

## Query Patterns

### Get User's Tasks
```python
statement = select(Task).where(Task.user_id == user_id)
tasks = db.exec(statement).all()
```

### Get User's Pending Tasks
```python
statement = select(Task).where(
    Task.user_id == user_id,
    Task.completed == False
)
tasks = db.exec(statement).all()
```

### Get User's Completed Tasks
```python
statement = select(Task).where(
    Task.user_id == user_id,
    Task.completed == True
)
tasks = db.exec(statement).all()
```

### Get Single Task with User Isolation
```python
statement = select(Task).where(
    Task.id == task_id,
    Task.user_id == user_id
)
task = db.exec(statement).first()
```

### Update Task
```python
task = db.exec(select(Task).where(Task.id == task_id, Task.user_id == user_id)).first()
if task:
    task.title = new_title
    task.description = new_description
    task.updated_at = datetime.utcnow()
    db.add(task)
    db.commit()
    db.refresh(task)
```

### Delete Task
```python
task = db.exec(select(Task).where(Task.id == task_id, Task.user_id == user_id)).first()
if task:
    db.delete(task)
    db.commit()
```

---

## Performance Considerations

### Index Effectiveness
- **user_id index**: Critical - used in 100% of queries
- **completed index**: High impact - used for status filtering
- **Composite index (user_id, completed)**: Future optimization if needed

### Query Optimization
- Always use `.where(Task.user_id == user_id)` first (most selective filter)
- Avoid `SELECT *` in production (select specific columns)
- Use `.first()` instead of `.all()` when expecting single result

### Connection Pooling
- Pool size: 10 base connections
- Max overflow: 20 additional connections
- Pre-ping: Enabled (handles serverless connection resets)

---

## Security Considerations

### User Isolation
- **ALL queries** must filter by `user_id`
- Use `user_id` from JWT token (not from URL path)
- Return 404 (not 403) for unauthorized resource access

### SQL Injection Prevention
- SQLModel ORM uses parameterized queries (safe by default)
- Never use string interpolation for queries
- Validate all input with Pydantic models

### Data Validation
- Title: 1-200 characters (prevent empty or excessively long titles)
- Description: Max 1000 characters (prevent abuse)
- User ID: Must match JWT token (prevent privilege escalation)

---

## Testing Strategy

### Unit Tests (Models)
```python
def test_task_model_creation():
    task = Task(user_id="user-123", title="Test Task", completed=False)
    assert task.title == "Test Task"
    assert task.completed == False
    assert task.user_id == "user-123"

def test_task_title_validation():
    with pytest.raises(ValidationError):
        Task(user_id="user-123", title="", completed=False)
```

### Integration Tests (Database)
```python
def test_user_isolation_query(db_session):
    # Create tasks for two users
    task1 = Task(user_id="user-1", title="Task 1", completed=False)
    task2 = Task(user_id="user-2", title="Task 2", completed=False)
    db_session.add_all([task1, task2])
    db_session.commit()

    # User 1 should only see their task
    user1_tasks = db_session.exec(select(Task).where(Task.user_id == "user-1")).all()
    assert len(user1_tasks) == 1
    assert user1_tasks[0].user_id == "user-1"
```

---

## Summary

- **Entities**: Task (User is implicit, managed by Better Auth)
- **Primary Key**: `tasks.id` (auto-increment integer)
- **User Isolation**: `user_id` field (indexed, always filtered)
- **Indexes**: user_id (required), completed (required)
- **Validation**: Pydantic models + SQLModel constraints
- **State**: Pending ↔ Completed (toggleable), Deleted (permanent)
- **Security**: User isolation enforced at query level

**Data Model Complete**: Ready for API contract design.
